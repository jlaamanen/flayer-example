var h=Object.create;var M=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var O=Object.getOwnPropertyNames;var C=Object.getPrototypeOf,F=Object.prototype.hasOwnProperty;var A=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports);var J=(e,n,r,o)=>{if(n&&typeof n=="object"||typeof n=="function")for(let t of O(n))!F.call(e,t)&&t!==r&&M(e,t,{get:()=>n[t],enumerable:!(o=L(n,t))||o.enumerable});return e};var j=(e,n,r)=>(r=e!=null?h(C(e)):{},J(n||!e||!e.__esModule?M(r,"default",{value:e,enumerable:!0}):r,e));var I=A((B,W)=>{var d=null;typeof WebSocket<"u"?d=WebSocket:typeof MozWebSocket<"u"?d=MozWebSocket:typeof global<"u"?d=global.WebSocket||global.MozWebSocket:typeof window<"u"?d=window.WebSocket||window.MozWebSocket:typeof self<"u"&&(d=self.WebSocket||self.MozWebSocket);W.exports=d});var y=class extends Error{},u=class extends y{},w=class extends y{};var N=j(I());async function E(e){if(!e)throw new Error("No URL provided. Did you forget to configure the client?");let n=new N.default(e);return new Promise((r,o)=>{n.addEventListener("open",()=>{r(n)}),n.addEventListener("error",t=>{o(t)})})}async function m(e,n){e.send(JSON.stringify(n))}function b(e,n,r){return new Promise((o,t)=>{let i=r!=null?setTimeout(()=>{t(new u("Timeout waiting for function result exceeded"))},r):null,a=f=>{try{let c=JSON.parse(f.data.toString());if(!K(c,n))return;if(clearTimeout(i),c.error){let S=c.error.name==="FlayerError"?y:Error,z=new S(c.error.message);t(z)}else o(c.data);e.removeEventListener("message",a)}catch{}};e.addEventListener("message",a),e.addEventListener("close",()=>{e.removeEventListener("message",a)})})}function K(e,n){return Object.keys(n).every(r=>e?.[r]===n[r])}var s={date:"@Date",map:"@Map",set:"@Set",bigInt:"@BigInt",regExp:"@RegExp",function:"@Function",special:"@SpecialValue",error:"@Error"};function R(e){return Array.isArray(e)&&e.length===2&&Object.values(s).includes(e[0])}var T=0;function D(e,n){let r=T++,o=async t=>{let i=JSON.parse(t.data);if(i.type!=="callback"||i.id!==r)return;let a=p(i.args,e),f=await n(...a);e.send(JSON.stringify({type:"callback",id:r,data:l(f,e)}))};return e.addEventListener("message",o),e.addEventListener("close",()=>{e.removeEventListener("message",o)}),r}function l(e,n){try{return JSON.stringify(e,(o,t)=>{if(typeof t=="object"&&!(t instanceof Map)&&!(t instanceof Set)&&!(t instanceof RegExp)&&t!=null){let i=Array.isArray(t)?[...t]:{...t};for(let a in t)t[a]instanceof Date&&(i[a]=[s.date,t[a].toISOString()]);return i}if(t instanceof Map){let i=l(Array.from(t.entries()),n);return[s.map,i]}if(t instanceof Set){let i=l(Array.from(t.values()),n);return[s.set,i]}if(t instanceof RegExp)return[s.regExp,[t.source,t.flags]];if(t instanceof Error)return[s.error,t.message];if(typeof t=="bigint")return[s.bigInt,t.toString()];if(typeof t=="function"){let i=D(n,t);return[s.function,i]}return typeof t=="number"&&isNaN(t)?[s.special,"NaN"]:t===1/0?[s.special,"Infinity"]:t===-1/0?[s.special,"-Infinity"]:t})}catch(r){throw new x(r.message)}}function p(e,n){if(!e)return e;try{return JSON.parse(e,(r,o)=>{if(!R(o))return o;let[t,i]=o;switch(t){case s.date:return new Date(i);case s.map:return new Map(p(i,n));case s.set:return new Set(p(i,n));case s.regExp:return new RegExp(i[0],i[1]);case s.error:return new Error(i);case s.bigInt:return BigInt(i);case s.function:let a=async(...f)=>{let c=i;m(n,{type:"callback",id:c,args:l(f,n)});let S=await b(n,{type:"callback",id:c});return p(S,n)};return Object.defineProperty(a,"name",{value:r,writable:!1}),a;case s.special:switch(i){case"NaN":return NaN;case"Infinity":return 1/0;case"-Infinity":return-1/0;default:return o}default:return o}})}catch(r){throw console.error(r),new Error("serialization_error")}}var x=class extends Error{constructor(n){super(`Serialization failed: ${n}`)}};function k(e){return window.flayer[e]}function g(e,n){window.flayer||(window.flayer={invocationId:0,ws:null,config:null}),window.flayer[e]=n}async function Y(e,n,r){let o=k("ws");if(!o||o.readyState!==o.OPEN){let f=k("config");if(!f)throw new y("Client not configured");try{o=await E(f.url),g("ws",o)}catch{throw new w("Error connecting to server")}}let t=k("invocationId");g("invocationId",t+1);let i=l(r,o);m(o,{type:"invocation",id:t,modulePath:e,functionName:n,data:i});let a=await b(o,{type:"result",id:t});return p(a,o)}async function Z(e){g("config",e),g("ws",await E(e.url))}async function v(){k("ws").close(),g("ws",null)}export{Z as configure,v as disconnect,Y as executeFlayerFunction};
//# sourceMappingURL=index.js.map
