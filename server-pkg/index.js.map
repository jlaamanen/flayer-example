{
  "version": 3,
  "sources": ["../node_modules/isomorphic-ws/browser.js", "../src/error.ts", "../src/websocket/client.ts", "../src/serialization.ts", "../src/client-lib/index.ts"],
  "sourcesContent": ["// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nmodule.exports = ws\n", "/**\n * General Flayer error\n */\nexport class FlayerError extends Error {}\n\n/**\n * Flayer timeout error\n */\nexport class FlayerTimeoutError extends FlayerError {}\n\n/**\n * Flayer connection error\n */\nexport class FlayerConnectionError extends FlayerError {}\n", "import WebSocket, { MessageEvent } from \"isomorphic-ws\";\nimport { FlayerError, FlayerTimeoutError } from \"../error\";\n\n/**\n * Creates a WebSocket client and connects to the provided Flayer server URL.\n * @param url Flayer server URL\n */\nexport async function connect(url: string) {\n  if (!url) {\n    throw new Error(\"No URL provided. Did you forget to configure the client?\");\n  }\n  const ws = new WebSocket(url);\n  return new Promise<WebSocket>((resolve, reject) => {\n    ws.addEventListener(\"open\", () => {\n      resolve(ws);\n    });\n    ws.addEventListener(\"error\", (error) => {\n      reject(error);\n    });\n  });\n}\n\n/**\n * Send any object as JSON via WebSocket\n * @param ws WebSocket\n * @param message Message as any object\n */\nexport async function sendMessage(ws: WebSocket, message: any) {\n  ws.send(JSON.stringify(message));\n}\n\n/**\n * Wait for a message that matches a given key/value condition.\n * @param ws WebSocket\n * @param condition Condition\n * @param timeout Timeout in milliseconds\n */\nexport function waitForMessage(\n  ws: WebSocket,\n  condition: { [key: string]: unknown },\n  timeout?: number\n) {\n  return new Promise<string>((resolve, reject) => {\n    // Set a timeout if it was provided\n    const timeoutHandle =\n      timeout != null\n        ? setTimeout(() => {\n            reject(\n              new FlayerTimeoutError(\n                \"Timeout waiting for function result exceeded\"\n              )\n            );\n          }, timeout)\n        : null;\n\n    const messageCallback = (message: MessageEvent) => {\n      try {\n        const jsonMessage = JSON.parse(message.data.toString());\n        if (!objectMatchesCondition(jsonMessage, condition)) {\n          return;\n        }\n        // A message matching the condition was received\n        clearTimeout(timeoutHandle);\n        if (jsonMessage.error) {\n          const SpecifiedError =\n            jsonMessage.error.name === \"FlayerError\" ? FlayerError : Error;\n          const error = new SpecifiedError(jsonMessage.error.message);\n          reject(error);\n        } else {\n          resolve(jsonMessage.data);\n        }\n        ws.removeEventListener(\"message\", messageCallback);\n      } catch (error) {\n        // Non-JSON message - ignore\n      }\n    };\n\n    // Assign the callback to WebSocket listeners\n    ws.addEventListener(\"message\", messageCallback);\n\n    // If connection is closed, remove the callback & reject the promise\n    ws.addEventListener(\"close\", () => {\n      ws.removeEventListener(\"message\", messageCallback);\n      reject(new FlayerError(\"Client disconnected\"));\n    });\n  });\n}\n\n/**\n * Checks if given object contains all expected key-value pairs\n * @param object Object\n * @param condition Condition object\n * @returns Does the object contain all the key-value pairs of the condition?\n */\nfunction objectMatchesCondition(\n  object: { [key: string]: unknown },\n  condition: { [key: string]: unknown }\n) {\n  return Object.keys(condition).every(\n    (key) => object?.[key] === condition[key]\n  );\n}\n", "import { WebSocket } from \"ws\";\nimport { Message } from \"./message\";\nimport { sendMessage } from \"./websocket/client\";\n\nexport const typeMarkers = {\n  date: \"@Date\",\n  map: \"@Map\",\n  set: \"@Set\",\n  bigInt: \"@BigInt\",\n  regExp: \"@RegExp\",\n  function: \"@Function\",\n  special: \"@SpecialValue\",\n  error: \"@Error\",\n} as const;\n\ntype TypeMarker = typeof typeMarkers[keyof typeof typeMarkers];\n\nfunction isSerialized(value: any) {\n  return (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    Object.values(typeMarkers).includes(value[0])\n  );\n}\n\n// Sequential ID for identifying callback functions\nlet callbackId = 0;\n\n/**\n * Starts a callback listener for \"serialized\" functions\n * @param ws WebSocket\n * @param fn Function\n */\nfunction startCallbackListener(ws: WebSocket, fn: Function) {\n  const id = callbackId++;\n\n  const callback = async (event: MessageEvent) => {\n    // Parse the message and ignore non-relevant messages\n    const message = JSON.parse(event.data) as Message;\n    if (message.type !== \"callback\" || message.id !== id) {\n      return;\n    }\n\n    // Matching message found - deserialize args and invoke the callback function\n    const args = deserialize(message.args, ws);\n    await fn(...args);\n  };\n\n  // Assign the callback as a WebSocket event listener\n  (ws as any).addEventListener(\"message\", callback);\n  // On disconnect remove the event listener\n  ws.addEventListener(\"close\", () => {\n    (ws as any).removeEventListener(\"message\", callback);\n  });\n\n  return id;\n}\n\n/**\n * Serializes the given object.\n *\n * If contains functions, starts listening to their invocations via WebSocket.\n *\n * @param object Object to be serialized\n * @param ws WebSocket\n * @returns Serialized string\n */\nexport function serialize(object: any, ws: WebSocket): string {\n  try {\n    const json = JSON.stringify(object, (_, value) => {\n      // Some values (e.g. Date) are serialized with toJSON _before_ running the replacer, making the values _always_ already serialized..\n      // Replace nested values when found inside an object/array before reaching the actual value.\n      if (\n        typeof value === \"object\" &&\n        !(value instanceof Map) &&\n        !(value instanceof Set) &&\n        !(value instanceof RegExp) &&\n        value != null\n      ) {\n        // Prevent mutations to the original object by creating a new one\n        const newValue = Array.isArray(value) ? [...value] : { ...value };\n        for (const key in value) {\n          if (value[key] instanceof Date) {\n            newValue[key] = [typeMarkers.date, value[key].toISOString()];\n          }\n        }\n        return newValue;\n      }\n      if (value instanceof Map) {\n        // Serialize the Map contents - add possible new functions to the function map too\n        const serialized = serialize(Array.from(value.entries()), ws);\n        return [typeMarkers.map, serialized];\n      }\n      if (value instanceof Set) {\n        // Serialize the Set contents - add possible new functions to the function map too\n        const serialized = serialize(Array.from(value.values()), ws);\n        return [typeMarkers.set, serialized];\n      }\n      if (value instanceof RegExp) {\n        return [typeMarkers.regExp, [value.source, value.flags]];\n      }\n      if (value instanceof Error) {\n        return [typeMarkers.error, value.message];\n      }\n      if (typeof value === \"bigint\") {\n        return [typeMarkers.bigInt, value.toString()];\n      }\n      if (typeof value === \"function\") {\n        const id = startCallbackListener(ws, value);\n        return [typeMarkers.function, id];\n      }\n      if (typeof value === \"number\" && isNaN(value)) {\n        return [typeMarkers.special, \"NaN\"];\n      }\n      if (value === Infinity) {\n        return [typeMarkers.special, \"Infinity\"];\n      }\n      if (value === -Infinity) {\n        return [typeMarkers.special, \"-Infinity\"];\n      }\n      return value;\n    });\n    return json;\n  } catch (error) {\n    throw new SerialiationError(error.message);\n  }\n}\n\n/**\n * Deserializes the given JSON string.\n *\n * If contains functions, wraps them into functions that send a message via WwbSocket.\n *\n * @param json Serialized object as JSON\n * @param ws WebSocket\n * @returns Deserialized object\n */\nexport function deserialize(json: string, ws: WebSocket) {\n  if (json == null) {\n    return null;\n  }\n  try {\n    return JSON.parse(json, (key, value) => {\n      if (!isSerialized(value)) {\n        return value;\n      }\n      const [type, serializedValue] = value as [type: TypeMarker, value: any];\n      switch (type) {\n        case typeMarkers.date:\n          return new Date(serializedValue);\n        case typeMarkers.map:\n          return new Map(deserialize(serializedValue, ws));\n        case typeMarkers.set:\n          return new Set(deserialize(serializedValue, ws));\n        case typeMarkers.regExp:\n          return new RegExp(serializedValue[0], serializedValue[1]);\n        case typeMarkers.error:\n          return new Error(serializedValue);\n        case typeMarkers.bigInt:\n          return BigInt(serializedValue);\n        case typeMarkers.function:\n          const fn = (...args: any[]) => {\n            const functionId = serializedValue;\n            sendMessage(ws, {\n              type: \"callback\",\n              id: functionId,\n              args: serialize(args, ws),\n            });\n          };\n          // Override function name with the key\n          Object.defineProperty(fn, \"name\", { value: key, writable: false });\n          return fn;\n        case typeMarkers.special:\n          switch (serializedValue) {\n            case \"NaN\":\n              return NaN;\n            case \"Infinity\":\n              return Infinity;\n            case \"-Infinity\":\n              return -Infinity;\n            default:\n              return value;\n          }\n        default:\n          // No special deserialization detected - return value as it was\n          return value;\n      }\n    });\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"serialization_error\");\n  }\n}\n\nexport class SerialiationError extends Error {\n  constructor(cause: string) {\n    super(`Serialization failed: ${cause}`);\n  }\n}\n", "import { WebSocket } from \"isomorphic-ws\";\nimport { ClientConfig } from \"../config/client-config\";\nimport { FlayerConnectionError, FlayerError } from \"../error\";\nimport { deserialize, serialize } from \"../serialization\";\nimport { connect, sendMessage, waitForMessage } from \"../websocket/client\";\n\ndeclare global {\n  interface Window {\n    flayer: {\n      invocationId: number;\n      ws: WebSocket;\n      config: ClientConfig;\n    };\n  }\n}\n\nfunction get<Key extends keyof typeof window[\"flayer\"]>(key: Key) {\n  return window.flayer[key];\n}\n\nfunction set<Key extends keyof typeof window[\"flayer\"]>(\n  key: Key,\n  value: typeof window[\"flayer\"][Key]\n) {\n  if (!window.flayer) {\n    window.flayer = {\n      invocationId: 0,\n      ws: null,\n      config: null,\n    };\n  }\n  window.flayer[key] = value;\n}\n\nexport async function executeFlayerFunction(\n  modulePath: string,\n  functionName: string,\n  args: any[]\n) {\n  let ws = get(\"ws\");\n  if (!ws || ws.readyState !== ws.OPEN) {\n    const config = get(\"config\");\n    if (!config) {\n      throw new FlayerError(\"Client not configured\");\n    }\n    try {\n      ws = await connect(config.url);\n      set(\"ws\", ws);\n    } catch (error) {\n      throw new FlayerConnectionError(\"Error connecting to server\");\n    }\n  }\n\n  let id = get(\"invocationId\");\n  set(\"invocationId\", id + 1);\n  const data = serialize(args, ws);\n  sendMessage(ws, {\n    type: \"invocation\",\n    id,\n    modulePath,\n    functionName,\n    data,\n  });\n\n  const result = await waitForMessage(ws, {\n    type: \"result\",\n    id,\n  });\n  return deserialize(result, ws);\n}\n\n/**\n * Configure the client to use a Flayer sever\n * @param config Client config\n * @returns WebSocket connection\n */\nexport async function configure(config: ClientConfig) {\n  set(\"config\", config);\n  set(\"ws\", await connect(config.url));\n}\n\n/**\n * Closes/invalidates the current WebSocket connection.\n * Connection will be reopened on the next function invocation.\n */\nexport async function disconnect() {\n  const ws = get(\"ws\");\n  ws.close();\n  set(\"ws\", null);\n}\n"],
  "mappings": "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",
  "names": []
}
